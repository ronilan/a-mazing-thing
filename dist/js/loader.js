(()=>{"use strict";class t{constructor(t){this.maze=t,this.path=[],this.start=[],this.goal=[],this.mappedMaze=this._mapMaze()}_mapMaze(){return this.maze.map(((t,n)=>t.map(((t,a)=>({row:n,column:a,parent:null,value:t,f:0,g:0,h:0})))))}_huristicDistance(t,n){return Math.abs(t[0]-n[0])+Math.abs(t[1]-n[1])}_findNeighbours(t){const n=this.mappedMaze,{row:a,column:e}=t,s=[];return void 0!==n[a+1]&&s.push(n[a+1][e]),void 0!==n[a][e+1]&&s.push(n[a][e+1]),void 0!==n[a-1]&&s.push(n[a-1][e]),void 0!==n[a][e-1]&&s.push(n[a][e-1]),s}_findPath(t){const n=[];let a=t;for(;a.parent;)n.push(a),a=a.parent;n.push(a),this.path=n.reverse()}solve(t,n){if(t.every((t=>this.start.includes(t)))&&n.every((t=>this.goal.includes(t)))&&this.path.length)return this.path;this.start=t,this.goal=n,this.path=[],this.mappedMaze=this._mapMaze();const a=[];let e=[this.mappedMaze[t[0]][t[1]]];for(;e.length>0&&e.length<500;){const t=e.reduce(((t,n)=>n.f<t.f?n:t));if(t.row===n[0]&&t.column===n[1]){this._findPath(t);break}e=e.filter((n=>n!==t)),a.push(t);const s=this._findNeighbours(t);for(let i=0;i<s.length;i+=1){const h=s[i];let o=!1;-1!==a.indexOf(h)||t.value||(-1===e.indexOf(h)&&(o=!0,e.push(h)),t.g+1<h.g&&(o=!0),o&&(h.parent=t,h.g=t.g+1,h.h=this._huristicDistance([h.row,h.column],n),h.f=h.g+h.h))}}return this.path}}!async function(){let n=await async function(){if(window.location.hash)try{const t=await window.fetch(`./mazes/${window.location.hash.substring(1)}.json`);return await t.json()}catch(t){return null}return null}();n||(n=function(t=null,n=null){const a=n||parseInt((window.innerWidth-30)/30,10),e=t||parseInt((window.innerHeight-30)/30,10);return{maze:new Array(e).fill(null).map((()=>new Array(a).fill(null).map((()=>Math.floor(3*Math.random())?0:Math.floor(10*Math.random())+1))))}}(window.mazeRows,window.mazeColumns));const a=new t(n.maze),e=new window.CustomEvent("mazed",{detail:{solver:a}});window.document.dispatchEvent(e)}()})();